# Лабораторная работа №4
## Основные понятия теории конечных автоматов

**Вариант 7:** `(n|<b|d>)(h|k)<z|m>c`

---

## 1. Цель работы

Изучение основных понятий теории конечных автоматов, освоение методов построения конечных автоматов Мили для распознавания регулярных языков и разработка программного симулятора конечного автомата на языке высокого уровня.

---

## 2. Постановка задачи

Дано регулярное выражение: **`(n|<b|d>)(h|k)<z|m>c`**

Необходимо:

1. Построить конечный автомат Мили (КНА 1-го рода), который осуществляет проверку входного слова на допустимость в заданном регулярном выражении
2. Задать построенный КНА тремя способами:
   - Матрицами переходов (Δ) и выходов (Λ)
   - Ориентированным графом (диаграммой переходов)
   - Автоматной матрицей
3. Реализовать программу-симулятор КНА на языке Python

### 2.1. Разбор регулярного выражения

Регулярное выражение: `(n|<b|d>)(h|k)<z|m>c`

**Обозначения:**
- `|` — альтернатива (выбор одного из вариантов)
- `<...>` — опциональность (0 или 1 раз)
- Конкатенация — последовательное следование

**Разбор по частям:**
1. `(n|<b|d>)` — либо `n`, либо опционально `b` или `d` (может быть пусто, `b` или `d`)
2. `(h|k)` — обязательно `h` или `k`
3. `<z|m>` — опционально `z` или `m` (может быть пусто, `z` или `m`)
4. `c` — обязательно `c`

**Примеры допустимых слов:**
- С префиксом `n`: `nhc`, `nkc`, `nhzc`, `nkzc`, `nhmc`, `nkmc`
- С префиксом `b`: `bhc`, `bkc`, `bhzc`, `bkzc`, `bhmc`, `bkmc`
- С префиксом `d`: `dhc`, `dkc`, `dhzc`, `dkzc`, `dhmc`, `dkmc`
- Без префикса: `hc`, `kc`, `hzc`, `kzc`, `hmc`, `kmc`

**Примеры недопустимых слов:**
- `nc` (пропущен символ из `(h|k)`)
- `nh` (пропущен обязательный символ `c`)
- `nhhc` (два символа из `(h|k)`)
- `nzc` (пропущен символ из `(h|k)`)

---

## 3. Конечный автомат Мили

### 3.1. Формальное определение

**S = <X, Q, U, δ, λ>**

где:
- **X = {n, b, d, h, k, z, m, c}** — входной алфавит
- **Q = {q₀, q₁, q₂, q₃, qf, qe}** — алфавит внутренних состояний
  - q₀ — начальное состояние
  - q₁ — прочитали символ из (n|b|d)
  - q₂ — прочитали символ из (h|k)
  - q₃ — прочитали символ из <z|m>
  - qf — конечное (допускающее) состояние
  - qe — состояние ошибки
- **U = {0, 1}** — выходной алфавит
  - 0 — слово не допущено (пока)
  - 1 — слово допущено
- **δ: X × Q → Q** — функция переходов
- **λ: X × Q → U** — функция выходов

### 3.2. Принцип работы

Автомат работает по принципу Мили (КНА 1-го рода):
- Выходной сигнал формируется одновременно с переходом
- Формулы:
  - `q(i) = δ(x(i), q(i-1))`
  - `u(i) = λ(x(i), q(i-1))`

Автомат начинает работу в состоянии q₀ и последовательно обрабатывает символы входного слова. Если после обработки всех символов автомат находится в состоянии qf, слово считается допустимым (принятым).

---

## 4. Способы задания КНА

### 4.1. Способ 1: Матрицы переходов (Δ) и выходов (Λ)

#### Матрица переходов Δ = ||δ(x, q)||

| q \ x | n | b | d | h | k | z | m | c |
|-------|---|---|---|---|---|---|---|---|
| **q₀** | q₁ | q₁ | q₁ | q₂ | q₂ | qe | qe | qe |
| **q₁** | qe | qe | qe | q₂ | q₂ | qe | qe | qe |
| **q₂** | qe | qe | qe | qe | qe | q₃ | q₃ | qf |
| **q₃** | qe | qe | qe | qe | qe | qe | qe | qf |
| **qf** | qe | qe | qe | qe | qe | qe | qe | qe |
| **qe** | qe | qe | qe | qe | qe | qe | qe | qe |

#### Матрица выходов Λ = ||λ(x, q)||

| q \ x | n | b | d | h | k | z | m | c |
|-------|---|---|---|---|---|---|---|---|
| **q₀** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| **q₁** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| **q₂** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| **q₃** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| **qf** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| **qe** | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

### 4.2. Способ 2: Граф переходов (Диаграмма переходов)

```
              n/0, b/0, d/0
            ┌──────────────┐
            │              ↓
         ┌─────┐        ┌─────┐
    ─────│ q₀  │        │ q₁  │
         └─────┘        └─────┘
            │              │
       h/0,k/0          h/0,k/0
            │              │
            └────────┬─────┘
                     ↓
                  ┌─────┐
                  │ q₂  │
                  └─────┘
                     │
            ┌────────┼────────┐
         z/0,m/0     │       c/1
            │        │        │
            ↓        ↓        ↓
         ┌─────┐            ┌─────┐
         │ q₃  │   c/1      │ qf  │ (конечное)
         └─────┘───────────→└─────┘
                                │
                         любой символ/0
                                ↓
                             ┌─────┐
                             │ qe  │ (ошибка)
                             └─────┘
                                ↑
                                │
                       любой неопределенный
                            переход/0
```

**Элементы графа:**
- Состояния обозначены кружками
- Переходы обозначены стрелками с пометками `вход/выход`
- qf — конечное (допускающее) состояние (обозначается двойным кружком)
- qe — состояние ошибки (поглощающее состояние)

### 4.3. Способ 3: Автоматная матрица M = ||mᵢⱼ||

Формат: `mᵢⱼ = Xᵢⱼ/Uᵢⱼ`, где:
- `Xᵢⱼ = {x | qⱼ = δ(x, qᵢ)}` — множество входов, переводящих из qᵢ в qⱼ
- `Uᵢⱼ = {u | qⱼ = λ(x, qᵢ)}` — соответствующие выходы

| из\в | **q₀** | **q₁** | **q₂** | **q₃** | **qf** | **qe** |
|------|--------|--------|--------|--------|--------|--------|
| **q₀** | — | n,b,d/0 | h,k/0 | — | — | z,m,c/0 |
| **q₁** | — | — | h,k/0 | — | — | n,b,d,z,m,c/0 |
| **q₂** | — | — | — | z,m/0 | c/1 | n,b,d,h,k/0 |
| **q₃** | — | — | — | — | c/1 | n,b,d,h,k,z,m/0 |
| **qf** | — | — | — | — | — | n,b,d,h,k,z,m,c/0 |
| **qe** | — | — | — | — | — | n,b,d,h,k,z,m,c/0 |

**Интерпретация:**
- Пустая ячейка (—) означает отсутствие перехода
- Запись `x,y,z/u` означает: при входных символах x, y или z из текущего состояния переходим в соответствующее состояние с выходом u

---

## 5. Листинг программы на языке высокого уровня

Программа реализована на языке Python 3 и представляет собой полнофункциональный симулятор конечного автомата Мили.

### 5.1. Основной файл: mealy_automaton.py

```python
#!/usr/bin/env python3
"""
Конечный автомат Мили для регулярного выражения
Вариант 7: (n|<b|d>)(h|k)<z|m>c
"""

class MealyAutomaton:
    """
    Класс, реализующий конечный автомат Мили
    """

    def __init__(self):
        # Определение алфавитов
        self.input_alphabet = {'n', 'b', 'd', 'h', 'k', 'z', 'm', 'c'}
        self.output_alphabet = {'0', '1'}
        self.states = {'q0', 'q1', 'q2', 'q3', 'qf', 'qe'}
        self.initial_state = 'q0'
        self.final_state = 'qf'
        self.error_state = 'qe'

        self.current_state = self.initial_state
        self.transitions = self._build_transitions()
        self.trace = []

    def _build_transitions(self):
        """
        Построение таблицы переходов
        Формат: transitions[(state, symbol)] = (next_state, output)
        """
        trans = {}

        # Из q0
        trans[('q0', 'n')] = ('q1', '0')
        trans[('q0', 'b')] = ('q1', '0')
        trans[('q0', 'd')] = ('q1', '0')
        trans[('q0', 'h')] = ('q2', '0')
        trans[('q0', 'k')] = ('q2', '0')

        # Из q1
        trans[('q1', 'h')] = ('q2', '0')
        trans[('q1', 'k')] = ('q2', '0')

        # Из q2
        trans[('q2', 'z')] = ('q3', '0')
        trans[('q2', 'm')] = ('q3', '0')
        trans[('q2', 'c')] = ('qf', '1')  # Успех!

        # Из q3
        trans[('q3', 'c')] = ('qf', '1')  # Успех!

        # Из qf и qe - все переходы в qe с выходом 0
        for symbol in self.input_alphabet:
            trans[('qf', symbol)] = ('qe', '0')
            trans[('qe', symbol)] = ('qe', '0')

        return trans

    def process(self, word):
        """
        Обработать входное слово
        Returns: True если слово допустимо
        """
        self.reset()
        for symbol in word:
            self.step(symbol)
        return self.current_state == self.final_state
```

---

## 6. Пример результата выполнения

### Запуск программы

```bash
python3 mealy_automaton.py
```

### Выход программы

```
======================================================================
Тестирование конечного автомата Мили
Вариант 7: (n|<b|d>)(h|k)<z|m>c
======================================================================

Слово: 'nhc'         -> ДОПУСТИМО
Слово: 'nkc'         -> ДОПУСТИМО
Слово: 'nhzc'        -> ДОПУСТИМО
Слово: 'nkzc'        -> ДОПУСТИМО
Слово: 'nhmc'        -> ДОПУСТИМО
Слово: 'nkmc'        -> ДОПУСТИМО
Слово: 'bhc'         -> ДОПУСТИМО
Слово: 'bkc'         -> ДОПУСТИМО
Слово: 'bhzc'        -> ДОПУСТИМО
Слово: 'bkzc'        -> ДОПУСТИМО
Слово: 'bhmc'        -> ДОПУСТИМО
Слово: 'bkmc'        -> ДОПУСТИМО
Слово: 'dhc'         -> ДОПУСТИМО
Слово: 'dkc'         -> ДОПУСТИМО
Слово: 'dhzc'        -> ДОПУСТИМО
Слово: 'dkzc'        -> ДОПУСТИМО
Слово: 'dhmc'        -> ДОПУСТИМО
Слово: 'dkmc'        -> ДОПУСТИМО
Слово: 'hc'          -> ДОПУСТИМО
Слово: 'kc'          -> ДОПУСТИМО
Слово: 'hzc'         -> ДОПУСТИМО
Слово: 'kzc'         -> ДОПУСТИМО
Слово: 'hmc'         -> ДОПУСТИМО
Слово: 'kmc'         -> ДОПУСТИМО
Слово: 'nc'          -> ОТКЛОНЕНО
Слово: 'abc'         -> ОТКЛОНЕНО
Слово: 'nh'          -> ОТКЛОНЕНО
Слово: 'nk'          -> ОТКЛОНЕНО
Слово: 'nhcc'        -> ОТКЛОНЕНО
Слово: 'xyz'         -> ОТКЛОНЕНО
Слово: 'h'           -> ОТКЛОНЕНО
Слово: 'k'           -> ОТКЛОНЕНО
Слово: 'nhhc'        -> ОТКЛОНЕНО
Слово: 'nkk'         -> ОТКЛОНЕНО
Слово: 'nzc'         -> ОТКЛОНЕНО
Слово: 'nmc'         -> ОТКЛОНЕНО

======================================================================
Детальная трассировка для слова 'nhzc':
======================================================================

Трассировка выполнения:
------------------------------------------------------------
Состояние    Вход     След. состояние    Выход
------------------------------------------------------------
q0           n        q1                 0
q1           h        q2                 0
q2           z        q3                 0
q3           c        qf                 1
------------------------------------------------------------

Результат: ДОПУСТИМО
Конечное состояние: qf
```

### Анализ работы автомата на примере слова 'nhzc'

| Шаг | Текущее состояние | Входной символ | Следующее состояние | Выход | Описание |
|-----|-------------------|----------------|---------------------|-------|----------|
| 0 | q₀ | n | q₁ | 0 | Прочитали 'n' из группы (n\|<b\|d>) |
| 1 | q₁ | h | q₂ | 0 | Прочитали 'h' из группы (h\|k) |
| 2 | q₂ | z | q₃ | 0 | Прочитали 'z' из группы <z\|m> |
| 3 | q₃ | c | qf | 1 | Прочитали 'c' — слово допущено! |

**Результат:** Слово 'nhzc' **ДОПУСТИМО**, так как автомат завершил работу в конечном состоянии qf с выходом 1.

---

## 7. Вывод

В ходе выполнения лабораторной работы были изучены основные понятия теории конечных автоматов и успешно построен конечный автомат Мили для распознавания регулярного языка.

**Основные результаты работы:**

1. **Теоретическая часть:**
   - Изучены основные понятия теории конечных автоматов
   - Освоены различия между автоматами Мили и Мура
   - Разобрано регулярное выражение `(n|<b|d>)(h|k)<z|m>c`
   - Определены все допустимые и недопустимые слова

2. **Построение КНА:**
   - Разработан конечный автомат Мили с 6 состояниями
   - Определены функции переходов δ и выходов λ
   - Автомат корректно распознает все слова, соответствующие регулярному выражению

3. **Способы задания:**
   - **Матрицы переходов и выходов** — наглядное табличное представление всех переходов
   - **Граф переходов** — визуальное представление структуры автомата
   - **Автоматная матрица** — компактная форма, объединяющая переходы и выходы

4. **Практическая реализация:**
   - Создан полнофункциональный симулятор на языке Python
   - Реализованы все функции автомата Мили
   - Добавлена трассировка для отладки и демонстрации работы
   - Проведено тестирование на 36 различных словах

5. **Верификация:**
   - Протестировано 24 допустимых слова — все распознаны корректно
   - Протестировано 12 недопустимых слов — все правильно отклонены
   - Детальная трассировка подтверждает корректность работы автомата

6. **Практическая значимость:**
   - Освоены фундаментальные концепции теории автоматов
   - Получен опыт формализации регулярных языков
   - Созданный симулятор может быть адаптирован для других регулярных выражений
   - Понимание работы КНА важно для изучения компиляторов, лексического анализа и теории формальных языков

Конечные автоматы являются мощным инструментом для описания и распознавания регулярных языков. Они находят широкое применение в компиляторах, текстовых редакторах, сетевых протоколах и других областях компьютерных наук.
